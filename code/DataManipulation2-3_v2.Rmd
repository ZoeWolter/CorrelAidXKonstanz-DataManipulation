---
title: "Datenbereinigung mit R"
author: "CorrelAid"
date: "23 11 2021"
output: html_document
---


## Preparation

```{r}
pacman::p_load(tidyverse, naniar, readxl)
```

```{r}
columns <- c("Schluessel", "Straftat", "Gemeindeschluessel", "Stadt_Landkreis", "Kreisart", "erfasste_Faelle_Anzahl", "erfasste_Faelle_Prozent", "ef_Versuche_Anzahl", "ef_Versuche_Prozent", "Schusswaffe_gedroht", "Schusswaffe_geschossen", "Aufklaerung_Anzahl", "Aufklaerungsquote", "TV_insgesamt", "TV_maennlich", "TV_weiblich", "nd_TV_Anzahl", "nd_TV_Anteil", "Sort", "leer","GemSchl", "Gem", "EW")

BKA <- read_excel("data/KR-F-01-T01-Kreise-Faelle-HZ_xls.xlsx", 
    col_names = columns, skip = 9)
```


# Block 2: Datentypen & Outlier
## Vektor Basics

Hier verwenden wir einige Funktionen aus dem **purrr** package, welches ein Core-Bestandteil des tidyverse ist, um einige Inkonsistenzen in Basis-R zu vermeiden.

Ein Vektor ist eine Sequenz von Elementen desselben Datentyps.
Es gibt zwei Typen von Vektoren:

  1. Atomare Vektoren, von diesen gibt es sechs Typen: logical, integer, double,   character, complex, und raw. Wovon integer und double Vektoren zusammen als as   numeric bezeichnet werden.

  2. Listen, wobei Listen wiederum andere Listen enthalten können.

Der Hauptunterschied zwischen atomaren Vektoren und Listen besteht darin, dass atomare Vektoren homogen sind, während Listen heterogen sein können.

Jeder Vektor hat zwei wichtige Eigenschaften:

1. Seinen Typ, welcher mit `typeof()` bestimmt werden kann.
```{r}
x1 <- "This is a sentence"
typeof(x1)

x2 <- 20
typeof(x2)

x3 <- 20L
typeof(x3)

x4 <- c(5, "A", 100)
typeof(x4)

x5 <- list(x1, x2, x3, x4)
typeof(x5)
x5

x5 %>% map(typeof)
```

2. Seine Länge, die mit `length()` bestimmt werden kann.
```{r}
length(x1)
length(x2)
length(x3)
length(x4)
length(x5)
x5 %>% map(length)
```

Vektoren können auch beliebige zusätzliche Metadaten in Form von Attributes enthalten. Diese Attributes werden verwendet, um erweiterte (augmented) Vektoren zu erstellen.
Es gibt drei wichtige Arten von erweiterte Vektoren:

- Factors werden auf integers aufgebaut
- Dates und date-times bauen auf numerics auf
- Data frames und tibbels werden basierend auf Listen aufgebaut


## Passen die Datentypen im BKA-Datensatz?

Hier verwenden wir das **tibble** package, welches ebenfalls ein Core-Bestandteil des tidyverse ist.

Fast alle Fuktionen aus dem tidyverse erzeugen tibbles. Sie sind deshalb eines der vereinheitlichenden Merkmale des tidyverse. Ein data frame kann mit der `as_tibble()` Funktion in einen tibble umgewandelt werden.
Da `read_excel()` jedoch direkt schon einen tibble als output hat, ist dies in diesem Fall nicht nötig

```{r}
BKA
glimpse(BKA)
```

Der Datentyp double ist für die numerischen Variablen, wie die Anzahl der erfassten Fälle oder die Anzahl der Aufklärungen, passend.
Im Datensatz haben wir auch einige charactor Vektoren (Gemeindeschluessel, Stadt_Landkreis, ...), diese werden wir für die weitere Analyse in factors umwandeln.
R verwendet factors, um kategorische Variablen zu behandeln, d.h. Variablen, die eine feste und bekannte Menge möglicher Werte haben. Sie sind ebenfalls hilfreich, um character Vektoren neu zu ordnen und deren Darstellung zu verbessern. Das **forcats** package, welches Core-Bestandteil des tidyverse ist umfasst eine Reihe von Funktionen für den Umgang mit **cat**egorical Variablen.

Einige Beispiele sind:

- `fct_reorder()` Neuordnung eines factors durch eine andere Variable.
- `fct_infreq()` Neuordnung eines factors nach der Häufigkeit der Werte.
- `fct_relevel()` Ändern der Reihenfolge eines factors von Hand.
- `fct_lump()` Zusammenfassen der am wenigst\meist häufigen Werte eines Faktors zu "other".

Mehr darüber erfahrt ihr in `vignette("forcats")`.

Hier fokusieren wir uns auf die Variable Kreisart und wandeln diese zunächst in einen factor um. Hier könnt entweder eine list mit den gültigen levels erstellen und diese dem levels Argument zuwesen (`factor(x, levels = list)`) oder dieses Argument nicht spezifizieren, dann werden die levels in alphabetischer Reihenfolge aus den Daten entnommen.

```{r}
BKA$Kreisart <- BKA$Kreisart %>% factor()

BKA %>% glimpse()

typeof(BKA$Kreisart)
unique(BKA$Kreisart)
attributes(BKA$Kreisart)
```

Für die nächsten Schritte filtern und gruppieren wir zunächst den BKA Datensatz und berechnen die durchschnittliche Anzahl an Stafttaten pro Kreisart
```{r}
gesamt_kreisart <- BKA %>%
  filter(Straftat == "Straftaten insgesamt") %>% 
  group_by(Kreisart) %>%
  summarise(
    Mean_Straftaten = mean(erfasste_Faelle_Anzahl, na.rm = TRUE),
    Sum_Straftaten = sum(erfasste_Faelle_Anzahl, na.rm = TRUE)
  )

gesamt_kreisart
```

Jetzt können wir zum Beispiel die Reihenfolge der factor levels in Abhängigeit einer anderen Variable verändern.
```{r}
# Wir schauen uns die Reihenfolge der factor levels an
attributes(gesamt_kreisart$Kreisart)

# Und so wird werden die durchschnittlichen Straftaten nach Kreisarten dargestellt
ggplot(gesamt_kreisart, aes(Mean_Straftaten, Kreisart)) + 
  geom_col()

# Wir verändern die Reihenfolge der factor levels in Abhängigkeit von der durchschnittlichen Anzahl an Straftaten nach Kreisarten "Mean_Straftaten"
gesamt_kreisart <- gesamt_kreisart %>% 
  mutate(Kreisart = fct_reorder(Kreisart, Mean_Straftaten))

# Nun schauen wir uns die Reihenfolge der factor levels erneut an
attributes(gesamt_kreisart$Kreisart)

# Und so wird werden die durchschnittlichen Straftaten nach Kreisarten jetzt dargestellt
ggplot(gesamt_kreisart, aes(Mean_Straftaten, Kreisart)) + 
  geom_col()
```

Wir können auch weniger häufig vorkommende factor levels in einer extra Gruppe zusammenfassen.
```{r}
gesamt_kreisart

BKA %>% 
  mutate(Kreisart = fct_lump(Kreisart, n = 3)) %>%
  count(Kreisart)
```


## Haben wir NA's im Datensatz?

Um diese Frage zu beantworten und die Häufigkeit deren Auftretens zu bestimmen nutzen wir das **naniar** package. Dies ist hilfreich für die Zusammenfassung und den Umgang mit NAs in R. Es versucht hierbei so konsistent wie möglich mit den Prinzipien des tidyverse zu sein. 
Es ist immer wichtig sich das Codebook des Datensatzes genau anzuschauen. In diesem erhaltet ihr Angaben über impliziete NA's. Zum Beispiel Werte wie 99, 98 oder -1, -2, die häufig zur Codierung bestimmter fehlender Werte genutzt werden. Diese für die meisten Analysen expliziert in NAs umgewadelt werden. Nachdem wir dies getan haben, können wir ihr Auftreten im Datensatz inspizieren. 

```{r}
# Zur Veranschaulichung filtern wir den Datensatz auf Observationen zu den "Straftaten insgesamt" und erstellen zwei neue Variablen mit NA's 
BKA_gesamt <- BKA %>%
  filter(Straftat == "Straftaten insgesamt") %>% 
  select(Straftat, Stadt_Landkreis, Kreisart, erfasste_Faelle_Anzahl) %>%
  mutate(erfasste_Faelle_neu = case_when(Kreisart != "SK" ~
                                           erfasste_Faelle_Anzahl),
         Kreisart_neu = as.character(Kreisart),
         Kreisart_neu = replace(Kreisart_neu, 
                                       erfasste_Faelle_Anzahl > 3000 &
                                         erfasste_Faelle_Anzahl < 4000, 
                                "Keine Angabe"),
         Kreisart_neu = replace(Kreisart_neu, 
                                       erfasste_Faelle_Anzahl >= 4000 & 
                                         erfasste_Faelle_Anzahl < 5000, 
                                "Unbekannt")) %>%
  replace_with_na_at(.vars = c("erfasste_Faelle_neu"),
                     condition = ~.x > 3000 & .x < 5000)
```

Hierdurch können wir uns einen Überblick über die Möglichkeiten des naniar packages verschaffen
```{r}
vignette("naniar") # Funktioniert nicht
vignette(package="naniar") # Suche nach allen Vignettes zum naniar package

vignette("naniar-visualisation")
```

Tibble mit der absuluten und prozentualen Anzahl an NA's pro Variable
```{r}
miss_var_summary(BKA_gesamt)
```

Überprüfen der Variable "Kreisart_neu" mit `summary()`
```{r}
table(BKA_gesamt$Kreisart_neu)
```

Um die NA's explizit zu codieren können wir zum Beispiel `replace_with_na()` nutzen oder "Kreisart_neu" in einen factor umwandeln und die factor levels hierbei angeben.
```{r}
BKA_gesamt <- BKA_gesamt %>% 
  replace_with_na(replace = list(Kreisart_neu =c("Keine Angabe", "Unbekannt")))

table(BKA_gesamt$Kreisart_neu)
miss_var_summary(BKA_gesamt)
```

```{r}
# Plot mit der Anzahl an NA's pro Variable
gg_miss_var(BKA_gesamt)

# Visualisierung der Position der NA's im Datensatz
vis_miss(BKA_gesamt)

# Visualisierung der bei selben Observationen auftretenden NA's
gg_miss_upset(BKA_gesamt)

# Plots der NA's in Abhängigkeit anderer Variablen
gg_miss_var(BKA_gesamt, facet = Kreisart)
```


## Haben wir Outlier im Datensatz?

Outlier sind Beobachtungen, die ungewöhnlich sind; Datenpunkte, die nicht in das Muster zu passen scheinen. Manchmal handelt es sich bei Outlier um Fehler bei der Dateneingabe; manchmal deuten Outlier auf wichtige neue wissenschaftliche Erkenntnisse hin.

Als Beispiel betrachten wir die Aufklärungsquote einzelner Straftatsbestände.

```{r}
BKA_einzeln <- BKA %>% 
  filter(Straftat != "Straftaten insgesamt")

BKA_einzeln_SK <- BKA %>% 
  filter(Straftat != "Straftaten insgesamt",
         Kreisart == "SK") %>% 
  mutate(Stadt_Landkreis = replace(Stadt_Landkreis, 
                                       erfasste_Faelle_Anzahl > 3000 &
                                         erfasste_Faelle_Anzahl < 4000, 
                                "Keine Angabe"),
         Stadt_Landkreis = replace(Stadt_Landkreis, 
                                       erfasste_Faelle_Anzahl >= 4000 & 
                                         erfasste_Faelle_Anzahl < 5000, 
                                "Nicht erfasst"))

```

Dazu betrachten wir zunächst die summary der Variable
```{r}
summary(BKA_einzeln$Aufklaerungsquote)
```

Auffällig ist der ungewöhnlich hohe maximale Wert von 300, da die Aufklärungsqoute zwischen 0 - 100% liegen sollte.

Wir betracheten deshalb auch noch ein Histogram der Variable
```{r}
BKA_einzeln %>% 
  ggplot() +
    geom_histogram(mapping = aes(Aufklaerungsquote), binwidth = 0.5)
```

Bei einer großen Datenmenge sind Outlier in einem Histogramm manchmal schwer zu erkennen. Der einzige Hinweis auf Outlier ist die ungewöhnlich hohe Grenze der x-Achse. Damit die Outlier leicht zu erkennen sind, können wir mit coord_cartesian() auf kleine Werte der y-Achse zoomen.
```{r}
BKA_einzeln %>% 
  ggplot() + 
    geom_histogram(mapping = aes(Aufklaerungsquote), binwidth = 0.5) +
    coord_cartesian(ylim = c(0, 50))
```

Bevor wir mit unserer Analyse fortsetzen können, müssen wir das beiligende Codebook nochmals genau anschauen und in Erfahrung bringen, wie es zu diesen Outliern kommen kann.


## Aufgabe Block 2

***Aufgabe 2:*** Nutzt den "BKA_einzeln_SK" Datensatz und überprüft, ob es bei der Variable implizite NA's gibt. Falls dies der Fall ist, nutzt `replace_with_na()` um diese explizit als NA's zu klassifizieren.
```{r}
table(BKA_einzeln_SK$Stadt_Landkreis)

BKA_einzeln_SK <- BKA_einzeln_SK %>% 
  replace_with_na(replace = list(Stadt_Landkreis = 
                                   c("Keine Angabe", "Nicht erfasst")))

table(BKA_einzeln_SK$Stadt_Landkreis)
BKA_einzeln_SK %>% glimpse()
```

***Aufgabe 2:*** Recodet die Variable "Stadt_Landkreis" als factor.
```{r}
BKA_einzeln_SK$Stadt_Landkreis <- BKA_einzeln_SK$Stadt_Landkreis %>% factor()
BKA_einzeln %>% glimpse()
```

***Aufgabe 3:*** Überprüft mit der `summary()`function, ob es bei der Variable "Aufklaerung_Anzahl" (die Aufklärungsanzahl einzelner Straftatsbestände je Stadtkreis) potenzielle Outlier gibt. 
Fortgeschritten: Nutzt ein Histogram der Variable "Aufklaerung_Anzahl", um potenzielle Outlier grafisch darzustellen.
```{r}
summary(BKA_einzeln_SK$Aufklaerung_Anzahl)

BKA_einzeln_SK %>% 
  ggplot() + 
    geom_histogram(mapping = aes(Aufklaerung_Anzahl), binwidth = 100)

BKA_einzeln_SK %>% 
  ggplot() + 
    geom_histogram(mapping = aes(Aufklaerung_Anzahl), binwidth = 100) +
    coord_cartesian(ylim = c(0, 50))
```



# Block 3: Manipulation

In diesem Abschnitt verwenden wir hauptächlich das **dplyr** package, welches ebenfalls ein Core-Bestandteil des tidyverse ist.


## dplyr Grundlagen

Im Folgenden seht ihr die fünf wohl wichtigsten **dplyr**-Funktionen, mit denen ihr die meisten Datenmanipulationsprobleme lösen könnt. Einige hiervon haben wir vorher schon genutzt.

- `filter()`: Hiermit könnt ihr Observations nach ihren Werten ausfählen/filtern
- `arrange()`: Ermöglicht es die Rows/Zeilen neue zu ordenen
- `select()`: Lässt euch variablen nach ihren Namen auswählen
- `mutate()`: Macht es möglich neue Variablen aus Funktionen bestehender Variablen zu erstellen
- `summarise()`: Hierdurch lassen sich viele Werte zu einem einzigen Wert zusammenfassen

Diese können alle in Verbindung mit `group_by()` verwendet werden, wodurch sich der Anwendungsbereich jeder Funktion von der Bearbeitung des gesamten Datensatzes auf die Bearbeitung nach Gruppen ändert


### Filter rows mit `filter()`

```{r}
filter(BKA, Straftat == "Straftaten insgesamt", erfasste_Faelle_Anzahl > 8000)
```


### Arrange rows mit `arrange()`

```{r}
arrange(BKA, desc(Schusswaffe_gedroht))
```


### Select columns mit `select()`

```{r}
select(BKA, Straftat, Stadt_Landkreis, Kreisart, erfasste_Faelle_Anzahl)
```


### Add new variables mit `mutate()`

```{r}
mutate(BKA, 
       TV_anteil_maennlich = (TV_maennlich / TV_insgesamt)*100,
       TV_anteil_weiblich = (TV_weiblich / TV_insgesamt)*100, 
       TV_anteil_insgesamt = TV_anteil_maennlich + TV_anteil_weiblich)

mutate(BKA, 
       Aufklaerungsquote = Aufklaerungsquote / 100)

```


### Grouped summaries mit `summarise()`

```{r}
BKA %>% 
  group_by(Kreisart) %>% 
  summarise(mean_geschossen = mean(Schusswaffe_geschossen, na.rm = TRUE))
```


## Aufgaben Block 3

***Aufgabe 1:*** Filtert den Datensatz nach Straßenkriminalität (`Straftat == "Straßenkriminalität"`) und reduziert ihn auf die Variablen Straftat, Stadt_Landkreis, Kreisart, erfasste_Faelle_Anzahl und Aufklaerung_Anzahl. 
```{r}
BKA %>% 
  filter(Straftat == "Straßenkriminalität") %>% 
  select(Straftat, Stadt_Landkreis, Kreisart, erfasste_Faelle_Anzahl,
         Aufklaerung_Anzahl)
```

***Aufgabe 2:*** Filtert den Datensatz nach Kreisfreien Städten ("KfS") und Handtaschenraub. Gruppiert den Datensatz im Anschluss nach den Kreisfreien Städten und fasst die gesamte Anzahl der erfassten Handtaschenraube pro Kreisfreie Städt in einer neuen Variable zusammen.
```{r}
BKA %>% 
  filter(Straftat == "Handtaschenraub", Kreisart == "KfS") %>% 
  group_by(Stadt_Landkreis) %>% 
  summarise(sum_handtaschen = sum(erfasste_Faelle_Anzahl, na.rm = TRUE))
```



