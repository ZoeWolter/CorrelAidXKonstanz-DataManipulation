---
title: "Data Manipulation and Preprocessing"
author: "CorrelAid"
date: "02 11 2021"
output: html_document
---


# Block 1: Getting started

## Daten importieren

Wer smart importiert kann später bei der Datenreinigung Zeit sparen.
Zum Importieren von Excel-Datensätzen nutzen wir in diesem Kurs das `readxl` package.
```{r}
# Package
library(readxl)
``` 

Wenn die Datei im gleichen Ordner/Verzeichnis/Directory liegt, wie das Projekt, kann die Datei mit dem einzigen Argument des Dateinames importiert werde. Allerdings ist das Format der Datei und die Variablennamen oft nicht optimal. 
```{r}
BKA_first <- read_excel("KR-F-01-T01-Kreise-Faelle-HZ_xls (1).xlsx")
View(BKA_first)

mean(BKA_first$`KfS = kreisfreie Stadt`) # die Spalte beinhaltet die absolute Anzahl der erfassten Fälle für die entsprechende geographische Einheit
class(BKA_first$`KfS = kreisfreie Stadt`)
mean(as.numeric((BKA_first$`KfS = kreisfreie Stadt`)))
mean(as.numeric((BKA_first$`KfS = kreisfreie Stadt`)), na.rm = TRUE)
```


Mithilfe der `args` Funktion können alle möglichen Argumente und falls vorhanden deren Standartwerte ermittelt werden. Das Fragezeichen öffnet die Help-Seite zu der entsprechenden Funktion. 

Um das Problem der nicht aussagekräftigen Variablennamen entgegenzuwirken, erstellen wir einen Vektor mit neuen Variablennamen. Die Namen müssen die gleiche Reihenfolge wie die Spalten in dem Datensatz haben. 
Zusätzlich verwenden wir das Argument `skip = 9` um die ersten 9 Zeilen nicht zu übernehmen. 
Diesen Datensatz speichern wir unter den Namen `BKA_preprocessed`.
```{r}
args(read_excel)
?read_excel

columns <- c("Schluessel", "Straftat", "Gemeindeschluessel", "Stadt_Landkreis", "Kreisart", "erfasste_Faelle_Anzahl", "erfasste_Faelle_100tausend", "ef_Versuche_Anzahl", "ef_Versuche_Prozent", "Schusswaffe_gedroht", "Schusswaffe_geschossen", "Aufklaerung_Anzahl", "Aufklaerungsquote", "TV_insgesamt", "TV_maennlich", "TV_weiblich", "nd_TV_Anzahl", "nd_TV_Anteil", "Sort", "leer","GemSchl", "Gem", "EW")

BKA_preprocessed <- read_excel("KR-F-01-T01-Kreise-Faelle-HZ_xls (1).xlsx", 
    col_names = columns, skip = 9)

```

## Übersichtsfunktionen

Die folgenden Funktionen geben einen schnellen Überblick über den Datensatz und seinen Eigenschaften
```{r}
head(BKA_preprocessed)
str(BKA_preprocessed)
names(BKA_preprocessed)
names(BKA_first)
```

## Pipeline

Mit der Pipeline kann das Programmieren intuitiver gestaltet werden. 
Um die Pipeline nutzen zu können, muss das package `tidyverse` geladen sein. 
`glimpse` ist die Übersichtsfunktion von tidyverse.
```{r}
# package
library(tidyverse)

# base R
glimpse(BKA_first)

# tidyverse
BKA_first %>%
  glimpse()

BKA_preprocessed %>%
  glimpse()

```

## AUFGABE BLOCK 1 

Ihr könnt jetzt Excel-dateien in R importieren und schon die ersten Verbesserungen/Anpassungen beim Import umsetzen.
Anbei eine weiteres package. Anders als `readxl` hilft dieses packages beim Import von csv-Datein. (csv - comma seperated values)
*Wichtig:* Beim Einlesen von csv-Dateien muss immer ein Trennzeichen (hier mit dem Argument `delim`) definiert werden.
Anbei nochmal die Help-Funktionen, die uns mehr Informationen zu den Funktionen liefern.
*Tipp:* Ihr könnt die Datei importieren, indem ihr unter dem Reiter `Files` den Datensatz raussucht, anklickt und `Import Dataset` auswählt. Achtung übernimmt den Code aus dem Fenster unten rechts unbedingt, damit ihr später noch wisst wie genau ihr den Datensatz importiert habt. 
```{r}
# package
library(readr)
args(read_delim)
?read_delim
```

Das BKA stellt ihre Fallstatistiken auch im csv-format zum Downloaden bereit.
Mithilfe der read_delim Funktion sollt ihr die Datei runterladen und dabei sicherstellen, dass die Dateinamen stimmen und die Dateitypen für jede Zeile Sinn ergibt (müssen noch nicht die optimalsten Dateitypen sein, aber in die richtige Richtung gehen)
Kontrolliert euern Import anschließend mithilfe der Pipeline.
Welches (unerwartete) Problem ist aufgetreten? - Umlaute
Habt ihr Ideen, wie man dieses Problem lösen kann??
```{r}
BKA_csv <- read_delim("KR-F-01-T01-Kreise-Faelle-HZ_csv.csv",
    ";", col_names = columns, trim_ws = TRUE, skip = 2)

BKA_csv %>% 
  glimpse()

```


# Welcome back!

-schnell in breakout-room -> recap/quiz (einfach und eng an session 1/ gutes gefühl geben)


# Block 5: Data Manipulation - Attributes und Regex

## Attributes

Attributes sind zusätzliche Informationen zum Objekt, die in einer Liste gespeichert werden.
Besonders nützlich sind Attributes, um die Zuordnung von labels und levels von kategorischen und ordinalen Variablen, oder eine genauere Beschreibung der Variable z.B. den Fragetext zu speichern. 
```{r}
# Attributes abrufen
attributes(BKA_preprocessed)                    # Attributes des Datensatzes 
attributes(BKA_preprocessed$Schluessel)         # Attributes einer spezifischen Variable (noch LEER)

# Beschreibung der Variable hinzufügen - Veränderung des Datensatzes im Viewer anschauen
attributes(BKA_preprocessed$Gemeindeschluessel)$label <- "numerischer Gemeindeschlüssel (Katalog)"

# labels-levels Zuordnung als named vector als attribute speichern

## named vector erstellen
Gemeindeschluessel_labels <- BKA_preprocessed$Gemeindeschluessel                               # alle Schlüssel speichern
names(Gemeindeschluessel_labels) <- BKA_preprocessed$Stadt_Landkreis                           # jedem Schlüssel einen Namen mit der entsprechenden geographischen Einheit geben 
Gemeindeschluessel_labels <- Gemeindeschluessel_labels[!duplicated(Gemeindeschluessel_labels)] # entfernen von Dopplungen (duplicate gibt einen logical vector zurück)

## named vector als labels in attributes-Liste speichern
attributes(BKA_preprocessed$Gemeindeschluessel)$labels <- Gemeindeschluessel_labels
attributes(BKA_preprocessed$Gemeindeschluessel)                                      # in attributes befindet sich jetzt sowohl eine genauere Beschreibung der Variable als auch ein Vector mit der Zuordnung von Schlüssel und Gemeinde.
```


## Strings manipulieren (Umlaute)

Wir erinneren uns an den CSV-Datensatz, der die Umlaute nicht richtig eingelesen hat. Die `gsub` Funktion sucht nach einer bestimmten Zeichenfolge und ersetzt sie mit einer anderen.
```{r}
unique(BKA_csv$Stadt_Landkreis)   # Umlaute werden cryptisch dargestellt

# für folgende Umlaute sehen wir momentan folgende Varianten
# ü = \xfc
# ö = \xf6
# ä = \xe4
# ß = \xdf

# Hier wird an jeder Stelle, an der eigentlich ein ü seien sollte, ein ue eingesetzt. 
# fixed steht dafür, dass ihr nur genau nach dieser Zeichenkette sucht und keine Variation davon (mehr dazu gleich unter dem Titel "regex")
# useBytes stellt sicher, dass die Zeichenketten Bytes für Bytes verglichen werden und nicht vorher in Buchstaben intepretiert werden.

BKA_csv$Stadt_Landkreis <- gsub(pattern = "\xfc", replacement = "ue", x = BKA_csv$Stadt_Landkreis, fixed = T, useBytes = T)
```

## Regex

Regex ist eine Abkürzung für den Ausdruck regular expression und beschreibt eine Typ von Zeichenkette. Anstelle wie vorher zu sagen, dass die Zeichenkette \\xfc durch ein ue ersetzt werden soll, können regex z.B. beschreiben, dass alle Zahlen aus einer Zeichenkette entfernt werden sollen. Es geht auch koplizierter, z.B. das alle Stellen die drei Zahlen gefolgt von drei Buchstaben enthalten entfernt werden sollen. 
Zum Üben wurden der Gemeindeschlüssel und der Ortsname mit einem Unterstrich verbunden und in der Variable `Name_Schluessel` gespeichert. 
Mit Regex können wir die Gemeindeschlüssel vom Ortsnamen trennen indem wir bestimmen, dass alle Zahlen zu Beginn der Zeichenkette bis zum Unterstrich entfernt werden sollen.
```{r}
# neue Variable erstellt, die wieder in ihre Einzelteile gebracht werden soll.
BKA_csv$Name_Schluessel <- paste(BKA_preprocessed$Gemeindeschluessel, BKA_preprocessed$Stadt_Landkreis, sep = "_")

# package
library(rebus)
# diese packages hilf bei der Definition der Zeichenkette, die identifiziert werden soll mit sprachlichen äquivalenten zu den Zeichen, die typischerweise bei regex erwartet werden.

pattern_schluessel <- START %R% one_or_more(DIGIT) %R% "_"

# mit gsub kann das Entfernen durchgeführt werden. Wichtig: Fixed = False muss angegeben werden, damit nicht nach der exakten Zeichenkette "^[0-9]*_" gesucht wird, sondern nach der Familie an Zeichenketten, die dieser Ausdruck repräsentiert.
# Hier ein paar Lösungsvarianten:
gsub("^[0-9]*_", "", BKA_csv$Name_Schluessel)
gsub("^[[:digit:]]*_", "", BKA_csv$Name_Schluessel)
gsub(pattern_schluessel, "", BKA_csv$Name_Schluessel)

```


## Aufgabe Block 5

Fügt Attributes zu der `Schluessel`-Variable, eine genauere Beschreibung unter dem Titel `label` und die Zuordnung von Schlüssel und Straftat mithilfe eines named vectors unter dem Titel `labels`.
Kontrolliert euer Ergebnis.

Korrigiert die restlichen Umlaute, die falsch intepretiert wurden.

Als Übung zum Thema regex entfernt ihr aus der Namen_Schuessel Variable, die Ortsnamen, sodass nur noch die Gemeindeschlüssel übrig bleiben.
Hilfe für die regex Aufgabe: http://edrub.in/CheatSheets/cheatSheetStringr.pdf

```{r}
# attributes
attributes(BKA_preprocessed$Schluessel) <- list(label = "6-stelliger numerischer PKS-Schlüssel (Katalog) für die Straftaten")
schluessel_labels <- unique(BKA_preprocessed$Schluessel)
names(schluessel_labels) <- unique(BKA_preprocessed$Straftat)
attributes(BKA_preprocessed$Schluessel)$labels <- schluessel_labels
attributes(BKA_preprocessed$Schluessel)

# gsub

# regex
gsub("[[:alpha:][:blank:][:punct:]]", "", BKA_csv$Name_Schluessel)
```

